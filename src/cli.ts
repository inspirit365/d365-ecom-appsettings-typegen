#!/usr/bin/env node

import fs from 'fs';
import chokidar from 'chokidar';

function printUsageAndExit(exitCode: number) {
    const log = exitCode === 0 ? console.log : console.error;
    log(
        'Usage: d365-ecom-appsettings-typegen [--watch|-w] [--output|-o <output-file>] \n' +
        '  --watch, -w       Watch for changes and regenerate automatically\n' +
        '  --output, -o      Specify the output file (default: src/settings/app.settings.autogenerated.ts)'
    );
    process.exit(exitCode);
}

const args = process.argv.slice(2);
const watchIndex = args.findIndex(arg => arg.toLowerCase() === '--watch' || arg.toLowerCase() === '-w');
const watchMode = watchIndex !== -1;

if (watchMode) {
    // Remove the watch flag from args
    args.splice(watchIndex, 1);
}

const inputFile = 'src/settings/app.settings.json';

const outputIndex = args.findIndex(arg => arg.toLowerCase() === '--output' || arg.toLowerCase() === '-o');
const outputFile = outputIndex !== -1 && args[outputIndex + 1] ? args[outputIndex + 1] : 'src/settings/app.settings.autogenerated.ts';

if (!outputFile) {
    printUsageAndExit(1);
}

function toTs(obj: any, name = 'IAppSettings'): string {
    const lines: string[] = [
        '// This file is autogenerated. Do not edit directly.',
        '',
        'import type { IAny, IGeneric } from \'@msdyn365-commerce/core-internal\';',
        '',
        `export interface ${name}InContext extends IGeneric<IAny> {`,
        `    config: ${name};`,
        '}',
        '',
        `export interface ${name} {`
    ];

    for (const [k, v] of Object.entries(obj.config)) {
        const typeInJson = obj.config[k].type as string;
        let typeInTs = 'any';

        const description = obj.config[k].description as string | undefined;
        if (description) {
            lines.push('    /**');
            lines.push(`     * ${description}`);
        }

        switch (typeInJson) {
            case 'string':
                const enumValues = Object.entries(obj.config[k].enum || {}) as [string, string][];
                if (enumValues.length > 0) {
                    lines.push(enumValues.map(x => `     * - \`${x[0]}\`: ${x[1].trimEnd()}`).join('\n'));
                    typeInTs = enumValues.map(x => `'${x[0]}'`).join(' | ');
                    break;
                }
            case 'number':
            case 'boolean':
                typeInTs = typeInJson;
                break;
            case 'array':
                const arrayType = obj.config[k].items?.type;
                const tsArrayType = ['string', 'number', 'boolean'].includes(arrayType) ? arrayType : 'any';
                typeInTs = `${tsArrayType}[]`;
                break;
        }

        const friendlyName = obj.config[k].friendlyName as string | undefined;
        if (friendlyName) {
            lines.push(`     * @friendlyName ${friendlyName}`);
        }

        const defaultValue = obj.config[k].default as string | number | boolean | any[] | undefined;
        const defaultValueFormatted = defaultValue === undefined
            ? 'undefined'
            : (Array.isArray(defaultValue) ? JSON.stringify(defaultValue) : defaultValue);
        if (defaultValue !== undefined) {
            lines.push(`     * @defaultValue \`${defaultValueFormatted}\``);
        }

        const required = obj.config[k].required as boolean | undefined;
        lines.push(`     * @required ${required === true ? 'true' : 'false'}`);

        const group = obj.config[k].group as string | undefined;
        if (group) {
            lines.push(`     * @group ${group}`);
        }

        if (description) {
            lines.push('     */');
        }

        lines.push(`    ${k}: ${typeInTs};`);
    }

    lines.push('}\n');
    return lines.join('\n');
}

function generate() {
    if (!fs.existsSync(inputFile)) {
        console.log(`Input file "${inputFile}" does not exist. Skipping generation.`);
        return;
    }

    try {
        const json = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));
        const ts = toTs(json);
        fs.writeFileSync(outputFile, ts, 'utf-8');
        console.log(`[appsettings-typegen] Generated: ${outputFile}`);
    } catch (error: any) {
        console.error("[appsettings-typegen] Failed:", error.message);
    }
}

if (watchMode) {
    generate();
    chokidar.watch(inputFile, { ignoreInitial: true }).on('change', () => {
        console.log(`[appsettings-typegen] Detected changes in ${inputFile}, regenerating...`);
        generate();
    });
} else {
    generate();
}